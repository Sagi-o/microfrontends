# Microfrontends

<a alt="Nx logo" href="https://nx.dev" target="_blank" rel="noreferrer"><img src="https://raw.githubusercontent.com/nrwl/nx/master/images/nx-logo.png" width="45"></a>

✨ **This workspace has been generated by [Nx, a Smart, fast and extensible build system.](https://nx.dev)** ✨

<img width="796" alt="Screenshot 2024-07-30 at 0 44 21" src="https://github.com/user-attachments/assets/08c863fd-a039-4488-9622-cdf722c84d3e">

## Project Explanation

1. `shell`, `mfe1` and `mfe2` are independant React applications, `server` is a simple Express server that serves the mfe bundles.
2. `shell` app uses `MfeLoader` component to load dynamically `mfe1` and `mfe2` via the `server` that returns their bundles as `application/javascript`.
Each microfrontend exports in it's `main.tsx` an object to the global window, which inside found the mounting function.
For example: `window.mfe1 = { mount: (container) => { ... } }`
3. Inside the `shell` application `index.html` - there is an import map, that maps each microfrontend `appName` to it's corresponding remote bundle URL, so that on runtime `MfeLoader` only needs to import the `appName` and it will be transformed to the remote URL found on the import map.
After the microfrontend is loaded, the `shell` can use the mounting function that corresponds to loaded mfe.
4. Import maps can help also with versioning, if one of the microfrontends gets updated with a new version, the import map can be changed, pointing the new version URL, then each `import(appName)` usage will be loaded with the new version.
5. Another advantage of import maps is that you can use the to share libraries on runtime that used in multiple micro frontends, for example we can create mapping to the `react` lib that will be mapped to `cdn.react-bundle.js`, then on runtime each mfe will use the same bundle because it's downloaded once in the browser. Don't forget to exclude the shared library from the `dependencies` record in `package.json`.

## Start the app

1. To build the micro-frontends run `npm run build-mfes`
2. To run the shell app and the server run `npm run app`

## Generate code

If you happen to use Nx plugins, you can leverage code generators that might come with it.

Run `nx list` to get a list of available plugins and whether they have generators. Then run `nx list <plugin-name>` to see what generators are available.

Learn more about [Nx generators on the docs](https://nx.dev/plugin-features/use-code-generators).

## Running tasks

To execute tasks with Nx use the following syntax:

```
nx <target> <project> <...options>
```

You can also run multiple targets:

```
nx run-many -t <target1> <target2>
```

..or add `-p` to filter specific projects

```
nx run-many -t <target1> <target2> -p <proj1> <proj2>
```

Targets can be defined in the `package.json` or `projects.json`. Learn more [in the docs](https://nx.dev/core-features/run-tasks).

## Want better Editor Integration?

Have a look at the [Nx Console extensions](https://nx.dev/nx-console). It provides autocomplete support, a UI for exploring and running tasks & generators, and more! Available for VSCode, IntelliJ and comes with a LSP for Vim users.

## Ready to deploy?

Just run `nx build demoapp` to build the application. The build artifacts will be stored in the `dist/` directory, ready to be deployed.

## Set up CI!

Nx comes with local caching already built-in (check your `nx.json`). On CI you might want to go a step further.

- [Set up remote caching](https://nx.dev/core-features/share-your-cache)
- [Set up task distribution across multiple machines](https://nx.dev/core-features/distribute-task-execution)
- [Learn more how to setup CI](https://nx.dev/recipes/ci)

## Connect with us!

- [Join the community](https://nx.dev/community)
- [Subscribe to the Nx Youtube Channel](https://www.youtube.com/@nxdevtools)
- [Follow us on Twitter](https://twitter.com/nxdevtools)
